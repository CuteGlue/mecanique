%% ceci est un commentaire 
%% il faut toujours commencer par \documentclass[type de papier, taille de texte]{sytle du document}
\documentclass[a4paper,10pt]{report} %%%% sytle du document : report/book/article
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% la suite est une collection des "package" ou des "librararies" pour utiliser des codes spécifiques
%% il vous suffit de les copie-coller quand vous créez un nouveau document TeX (ou bien en ajouter plus si besoin).
\usepackage[utf8]{inputenc} %% pour les accents en français
\usepackage[frenchb]{babel} %% pour un format français
\usepackage{graphicx} %% pour afficher des graphiques
\usepackage{amsmath} %% pour écrire des symboles (maths), des équations, etc.
\usepackage{amssymb}
\usepackage{color}
\usepackage{bm} %% pour lister des citations/la biblio
\usepackage{hyperref} %% pour inserer des liens internet
\usepackage{cleveref} %% pour faire des références uax équations, tableaux, etc.
\usepackage{cite}
\usepackage{float}
%\usepackage{setspace} %% pour changer l'espace entre les lignes
%\linespread{1.6} %% pour changer l'espace entre les lignes
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Default fixed font does not support bold face
\DeclareFixedFont{\ttb}{T1}{txtt}{bx}{n}{8} % for bold
\DeclareFixedFont{\ttm}{T1}{txtt}{m}{n}{8}  % for normal
% Custom colors
\usepackage{color}
\definecolor{deepblue}{rgb}{0,0,0.5}
\definecolor{deepred}{rgb}{0.6,0,0}
\definecolor{deepgreen}{rgb}{0,0.5,0}
\usepackage{listings}
% Python style for highlighting
\newcommand\pythonstyle{\lstset{
language=Python,
breaklines=true,
basicstyle=\ttm,
otherkeywords={self},             % Add keywords here
keywordstyle=\ttb\color{deepblue},
emph={MyClass,__init__},          % Custom highlighting
emphstyle=\ttb\color{deepred},    % Custom highlighting style
stringstyle=\color{deepgreen},
frame=tb,                         % Any extra options here
showstringspaces=false 
           % 
}}
% Python environment
\lstnewenvironment{python}[1][]
{
\pythonstyle
\lstset{#1}
}
{}
% Python for external files
\newcommand\pythonexternal[2][]{{
\pythonstyle
\lstinputlisting[#1]{#2}}}
% Python for inline
\newcommand\pythoninline[1]{{\pythonstyle\lstinline!#1!}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\title{------ Méthodes des Éléments Finis en 1D ------} %% choissez un titre approprié à votre sujet
\author{par\\MAAMIR, Mohamed\\ ZHANG, Xunjie\\ Compte-rendu du TP 1 de l'UE Méthodes des Éléments Finis} %% utilisez \\ pour une nouvelle ligne
\date{fait le 22 octobre 2016} %% pour afficher la date actuelle commenter cette ligne
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% TOUT ce qui va dans votre rapport doit être entre \begin{document} & \end{document}
\begin{document}
\selectlanguage{french} %% format français
\maketitle %% pour afficher le titre
\tableofcontents %% pour afficher/compiler le sommaire automatiquement
\listoffigures %% pour lister les figures
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Introduction et Modélisation par Éléments Finis}

\section{Introduction}

Dans le cadre de ce premier TP de MEF, nous avons étudié le déplacement des éléments d'une pale (de section variable)en rotation constante et soumise seulement à la force centrifuge.
Dans un premier temps, nous avons fait l'étude mathématique du modèle et trouvé une solution analytique des déplacements $u(r)$.Par la suite, grâce aux méthodes des éléments finis en 1D, nous avons construit un système linéaire à résoudre avec les outils numériques.
Nous avons programmé sur Python un algorithme permettant de construire les éléments du système à résoudre pour trouver les valeurs approchées de $u(r)$ sur différents points du maillage. La résolution de ce système de manière numérique nous a permis de construire cette approximation.
Par la suite, nous avons étudié les erreurs relatives et l'effet du changement de la densité du maillage dans la solution trouvée.
Ce compte-rendu décrit précisément les étapes de résolutions analytiques et numériques. De même, nous y analysons les résultats trouvés.

\section{Problème Physique}

\subsection{Équation d'Équilibre}

Un petit élément de la pale de largeur $\delta r$ et de section $S(r)$ est soumis aux actions suivantes :
\begin{enumerate}
	\item Force centrifuge : $(\rho*S(r)*\omega^2*r)*\Delta r$
	\item Efforts internes : $ES(r+\Delta r)\frac{du}{dr}|_{r+\Delta r}-ES(r)\frac{du}{dr}|_{r}=\frac{d}{dr}*[ES(r)\frac{du}{dr}(r)]$
\end{enumerate}


On retrouve donc à l'état d'équilibre l'équation suivante :
\begin{equation}
	\frac{d}{dr}(ES(r)\frac{du}{dr})+(\rho S(r)\omega^2)r =0
	\label{eqequilibre}
\end{equation}

\section{Formulation Faible}

Pour une fonction test $v(r)$, on retrouve une formulation faible de la forme:
\begin{center}
Trouver $u(r)$ tel que $u(0)=0$ et $\frac{du}{dr}\Big|_{r=L}=0$ :
	\begin{equation}
		\int_0^L \!ES(r)\frac{du}{dr}\frac{dv}{dr}~dr=\int_0^L \! \big(\rho S(r)\omega^2r\big)v(r)~dr
		\label{formulationfaible}
	\end{equation}
	$\forall v(0)=0$ et $\frac{dv}{dr}\big|_L=0$
\end{center}


\subsection{Solution Analytique}

L'équation d'équilibre est une \textbf{équation différentielle linéaire d'ordre deux}. Sa résolution est possible et est de manière relativement simple. De plus, nous avons \textbf{deux conditions limites} qui vont pouvoir nous aider à trouver les valeurs des constantes d'intégration.
\begin{enumerate}
	\item Dirichlet : $u(0)=0$
	\item Neumann :$\frac{du}{dr}\Big|_{r=L}=0$
\end{enumerate}

\subsubsection{Cas d'une Section Constante}

Si on considère la section $S_{const}$ comme étant constante, en intégrant l'équation d'équilibre (\ref{eqequilibre}) et en utilisant les conditions limites de Dirichlet et de Neumann, on retrouve une solution analytique de la forme:
\begin{equation}
	u(r)_{S_{const}}=\frac{\rho \omega^2}{2*E}\big(L^2 r-\frac{r^3}{3}\big)
	\label{solsconst}
\end{equation}

\subsubsection{Cas d'une Section non-constante}

Dans notre TP, nous avons considéré la section comme étant variables linéairement et étant de la forme :

$$S=S(r)=a*r+b$$
avec
$$a=\frac{S(L)-S(0)}{L},b=S(0)$$ 

En intégrant l'équation d'équilibre (\ref{eqequilibre})avec les mêmes conditions limites que précédemment, on retrouve une solution analytique de la forme:
\begin{multline}
	u(r)_{S(r)}=\frac{\omega^2 \rho}{36a^3E}\Big( ar(-4a^2r^2-3abr+6b^2)-6(b-2aL)(aL+b)^2\ln(ar+b)\\+6\ln(b)(b-2aL)(aL+b)^2 \Big)
	\label{solution u}
\end{multline}

\textit{Résolu avec Wolfram Alpha\textregistered : \href{https://goo.gl/IB3dHC}{This link}}

\section{la forme d'approximation par interpolation}
\section{Expressions des matrices A et B }
\subsection{Fonctions de Bases}
Pour un maillage de $N$ éléments : $M^h=\bigcup_{i=1}^{N} e_k$. On peux considérer l'approximation recherchée comme une sommes de fonctions de base tel que:
\begin{equation}
	u^h(x)=\sum_{i=0}^n u_{i}*\Phi_{i}(x)
	\label{discretisation de u}
\end{equation}
On peut considérer les fonctions tests de la forme d'un polynôme de degré $n$. C'est fonction de base servent a définir l'allure de la courbe entre deux valeurs $u_{i}$.
Ainsi, si on pose la fonction test $v^h(x)=\delta u^h(x)=\frac{\delta u^h}{\delta u_i}$, on retrouve
$$v^h(x)=\delta (\sum_{i=0}^n u_{i}*\Phi_{i}(x))=\sum_{i=0}^n \Phi_{i}(x)$$.

\subsection{Fonctions de Formes}

Les fonctions de forme donnent la forme d'un polynôme de degré $n$ sur un élément de référence $\hat{e}$. Un changement de variable nous permet de passer des fonctions de base aux fonctions de forme. Ces fonctions de forme vont nous permettre de définir la courbe sur chaque élément de manière plus simple.

Le passage entre les deux notations se fait comme suit :

\begin{displaymath}
		x=x_{k-1}\frac{1-\xi}{2}+x_{k}\frac{1+\xi}{2} \Leftrightarrow \xi=2\frac{x-x_{k-1}}{x_{k}-x_{k-1}}-1
\end{displaymath}

\subsubsection{Ordre 2}

Comme vue dans le cours, l'approximation $u^{h}$ sur un élément du maillage s'écrit:
\begin{displaymath}
u^{h}(x)=\sum_{i=0}^{nn}u_{i}\Phi_{i}(x)\end{displaymath}

Pour une approximation d'ordre 2, on découpe l'élément de référence $\hat{e}$ en 3 points d'interpolations $[-1,,0,1]$ qui représentent respectivement sur $e_{k}$ les points ($(n_{1},n_{2},n_{3})$) tel que:
\begin{displaymath}
u^{h}_n(x)=u_{n_{1}}\Phi_{n_{1}}(x)+u_{n_{2}}\Phi_{n_{2}}(x)+u_{n_{3}}\Phi_{n_{3}}(x)\end{displaymath}

On retrouve la relation entre les fonctions de base  $\Phi_{n_{q}}(x)$ et les fonctions de forme $N_{q}(\xi)$ :
\begin{displaymath}
\Phi_{n_{1}}(x)=N_{1}(\xi), \Phi_{n_{2}}(x)=N_{2}(\xi), \Phi_{n_{3}}(x)=N_{3}(\xi)\end{displaymath}

avec 
\begin{displaymath}
N_{1}(\xi)=\frac{\xi(\xi-1)}{2},  N_{2}(\xi)=\frac{\xi(\xi+1)}{2},  N_{3}(\xi)=1-\xi^{2}\end{displaymath}

\subsubsection{Ordre 1}

On retrouve la même démarche pour le cas d'ordre 1. Cette fois-ci, nous n'avons besoin que de deux nœuds ($(n_{1},n_{2}$) sur sur $e_{k}$.
Ainsi nous avons les fonctions de formes suivantes :
\begin{displaymath}
N_{1}(\xi)=\frac{1-\xi}{2} \mbox{  et  }  N_{2}(\xi)=\frac{1+\xi}{2}
\end{displaymath}
On retrouve donc:
\begin{displaymath}
u^{h}_n(x)=u_{n_{1}}\Phi_{n_{1}}(x)+u_{n_{2}}\Phi_{n_{2}}(x)\end{displaymath}

\subsection{Interpolation Polynomiale}

Pour un polynôme d'ordre $n$ tel que :
$$p(x) = a_n x^n + a_{n-1} x^{n-1} + \cdots + a_2 x^2 + a_1 x + a_0. \qquad$$ 
Et vérifiant $$p(x_i) = y_i,\qquad \forall i \in \left\{ 0, 1, \dots, n\right\}$$
On obtient un système linéaire à résoudre de la forme suivante :
\begin{equation}
\begin{pmatrix}
x_0^n & x_0^{n-1} & x_0^{n-2} & \ldots & x_0 & 1 \\
x_1^n & x_1^{n-1} & x_1^{n-2} & \ldots & x_1 & 1 \\
\vdots & \vdots & \vdots & & \vdots & \vdots \\
x_n^n & x_n^{n-1} & x_n^{n-2} & \ldots & x_n & 1 
\end{pmatrix}
\begin{pmatrix}
a_n \\
a_{n-1} \\
\vdots \\
a_0
\end{pmatrix}
=
\begin{pmatrix}
y_0 \\
y_1 \\
\vdots \\
y_n
\end{pmatrix}
\end{equation}

\subsubsection{Interpolation d'ordre 1}

Dans le cas d'une interpolation d'ordre 1, chaque nœud d'un maillage est relié au suivant par une fonction affine de la forme : $f_{k}(x)=\alpha*x+\beta$.

Pour un maillage $M^h$ avec $N$ éléments $e_{k}$ et $N+1$ nœuds $r_{k}$, avec $k\in [0,N],k\in\mathbb{Z}$, nous pouvons facilement déduire la forme de l'interpolation sur chaque élément $e_{k}$ :

\begin{equation}
	u^h_{k}(x)=\Big(\frac{U^h(r_{k})-U^h(r_{k-1})}{r_{k}-r_{k-1}}\Big)x+(\frac{r_{k}U^h(r_{k-1})-r_{k-1}U^h(r_{k})}{r_{k}-r_{k-1}}\Big)
	\label{interpolationP1}
\end{equation}

Ainsi pour un élément 

\subsubsection{Interpolation d'ordre 2}

Dans le cas d'une interpolation d'ordre 2, chaque nœud d'un maillage est relié au suivant par un polynôme d'ordre 2 de la forme : $f_{k}(x)=\alpha*x^2+\beta*x+\gamma$. Le système à résoudre pour une élément $e_k$ ($r\in[r_{k-1},r_{k}]$) est de cette forme:

\begin{equation}
\begin{pmatrix}
r_{k-2}^2 & r_{k-2} & 1 \\
r_{k-1}^2 & r_{k-1} & 1 \\
r_{k}^2 & r_{k} & 1 
\end{pmatrix}
\begin{pmatrix}
\alpha \\
\beta \\
\gamma
\end{pmatrix}
=
\begin{pmatrix}
U^h(r_{k-2}) \\
U^h(r_{k-1}) \\
U^h(r_{k})
\end{pmatrix}
\end{equation}
Nous devons ajouter un troisième point ($r_{k-1}$) à l'intervalle pour résoudre ce système. Ainsi, en augmentant la densité du maillage tel que : $N_2=2*N+1$, nous pouvons construire une interpolation d'ordre deux sur chaque élément. Si notre calcul numérique se fait nœud par nœud, le polynôme trouvé tiendra compte de la valeur précédente et ainsi de suite. La courbe finale sera ainsi continue.

\subsection{Système linéaire pour un élément k}

Soit la solution approchée :
$$u^{h}(x)=\sum_{i=0}^{n}u_{i}\Phi_{i}(x)$$
Si on pose pour $$v_i(x)=\Phi_{i}(x)$$ Alors $$\frac{\delta u^h}{\delta x}=\sum_{i=0}^{n}u_{i}\frac{\delta \Phi_{i}}{\delta x}$$ 

Et en partant de la formulation faible, nous trouvons ce système:
\begin{equation}
	\Big[ \int_0^L \!ES(r)\frac{d\Phi_{i}}{dr}\frac{\Phi_{j}}{dr}~dr \Big]*u_j=\int_0^L \! \big(\rho S(r)\omega^2r\big)\Phi_{i}~dr
	\label{eqsys}
\end{equation}

On retrouve un système linéaire $A*\vec{U}=\vec{B}$, avec :
$$dim (A) = (N+1)\times(N+1), dim (U)=dim(B)=(N+1)$$

Ainsi, connaissant l'équation d'équilibre sur un élément $e_k$ (\ref{eqequilibre}) et sa formulation faible (\ref{formulationfaible}), nous pouvons écrire, que pour un élément $e_k$, la matrice $A^k$ est de la forme $2\times2$ et s'écrit de cette façon :

\begin{equation}
	A^k_{ij}=\int_{e_k} \!ES(r)\frac{d\Phi_{ki}}{dr}\frac{\Phi_{kj}}{dr}~dr
\end{equation}
Si on considère $S(r)|_{e_k}=\frac{S(r_k)+S(r_k+1)}{2}$ constante sur l'élément, alors :
\begin{equation}
	A^k_{ij}=ES_{e_k} \int_{e_k} \frac{d\Phi_{ki}}{dr}\frac{\Phi_{kj}}{dr}~dr
	\label{matrixA}
\end{equation}



\subsubsection{Cas d'ordre 1}
Dans le cas d'ordre 1, nous avons :
	$$\frac{d\Phi_{k1}}{dr}=\frac{1}{N_2-N_1}=\dfrac{1}{h_k}$$
	et
	$$\frac{d\Phi_{k2}}{dr}=\frac{-1}{N_2-N_1}=\dfrac{-1}{h_k}$$
Soit :
\begin{equation}
	A^k=\frac{ES_{e_k}}{h_k}\begin{bmatrix}
    1 & -1 \\
    -1 & 1
  \end{bmatrix}
\end{equation}
	
On procède de la même façon pour le membre de droite de l'équation \ref{eqsys} pour trouver $B^k$

\begin{equation}
	B^k = S_{e_k}h_k\rho\omega^2 \begin{bmatrix}
    1/3 & 1/6 \\
    1/6 & 1/3
  \end{bmatrix}*
\begin{bmatrix}
    N_1 \\
    N_2 
  \end{bmatrix}  
\end{equation}
\subsubsection{Cas d'ordre 2}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Résolution numérique} %% pour commencer un chapitre

L'objectif du programme est de construire puis de résoudre un système linéaire fermé. Pour ce faire, nous avons préalablement trouvé la forme du système ainsi que ses conditions limites.
Par la suite, nous étudierons l'influence du maillage dans l'approximation des valeurs analytiques. Faute de temps, nous n'avons pas pu étudier le cas l'interpolation est d'ordre 2. Néanmoins, notre programme peut être facilement utilisé dans ce cas, les seuls éléments qui changeront seront le nombre de nœuds et la forme analytique de $A$ et $B$.
Le Programme a été codé en \textit{Python 2.7}.


\section{Algorithme}

La construction de la matrice $A$ et du vecteur $B$ se font de manière relativement simple. En effet, nous devons calculer $A^k$ et $B^k$ pour chaque élément, puis les assembler, avant de résoudre le système.
La façon la plus simple est de remplir $A$ $B$, en incrémentant la valeur de $k$.

En retrouve cette forme:

$$A^k =\begin{bmatrix}
A^k_11 + A^{k-1}_22 & A^k_12 \\
A^k_12 & A^k_22 + A^{k+1}_11
\end{bmatrix}, k \neq 0, k \neq N$$

On tiendra compte des valeurs limites et de la particularité des valeurs de $A^1_{11}$,$B^1_{11}$ et $B^N_{12}$ qui ne requière pas d'addition avec des valeurs voisines.
Une fois le système implémenté, sa résolution et la comparaison avec les valeurs analytique seront relativement simples.

\section{Programme}

Le programme se décompose en trois parties. Nous avons d'abord défini les fonctions qui nous permettront de construire notre système, ainsi que la solution analytique. Puis, nous avons étudié la solution approchée pour des paramètres donnée et avec un maillage avec 5 éléments ($N=5$).Nous avons terminé le programme avec une étude de l'erreur relative en un point donné en fonction de la variation du nombre de nœuds.

Le programme fonctionne très bien et est joint en annexe. Il sauvegarde automatiquement les courbes tracées.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Résultats et Conclusions}

\section{Résultats}
 
\subsection{Solution approchée pour N=5}

\subsubsection{Courbe approchée}
\begin{figure}[H]
\begin{center}
	\includegraphics[width=0.7\textwidth]{{"FIG/U Uh N5"}.png}
\end{center}
\caption{Solution approchée pour $N=5$}
\label{U Uh N5}
\end{figure}
Les valeurs sont de l'ordre de grandeur des déplacements possibles dans nos modèles physiques connues.
On remarque très bien que les valeurs trouvées numériquement sont très proches de celle de la courbe analytique en rouge. On peut aussi voir que si on fait une interpolation polynomiale d'ordre 1, c'est-à-dire relier tous les points bleus par des droites, la forme de la solution approchée sur des valeurs autre que celle des nœuds reste inexacte et ne correspond pas à la forme de la solution analytique.


\subsubsection{Erreur relative en chaque nœud}
\begin{figure}[H]
\begin{center}
	\includegraphics[width=0.7\textwidth]{{"FIG/Erreur relative N5"}.png}
\end{center}
\caption{Erreur relative en chaque nœud pour $N=5$}
\label{Erreur relative N5}
\end{figure}


Sur chaque nœud, nous avons calculé l'erreur relative de la solution approchée  $$Err = \frac{||u-u_{h}||}{||u||}$$
On remarque qu'elle est très faible et qu'elle diminue légèrement en fonction de $r$. On voit aussi que pour le premier nœud, ou $r=0$, nous avons un écart important, même si les valeurs des solutions analytique et approchée tendent vers $0$. Cette erreur numérique est due au fait que l'erreur relative ne peut être calculée en ce point. Ce que nous avons sont des valeurs très proches de $0$, mais non nulles que l'ordinateur calcul quand même. On peut ne pas tenir compte de cet effet de bord.

\subsection{Étude pour N croissant}
\subsubsection{Solutions Approchées}
\begin{figure}[H]
\begin{center}
	\includegraphics[width=0.7\textwidth]{{"FIG/Solutions Approchees & Analytique"}.png}
\end{center}
\caption{Solutions Approchées pour un nombre de nœud croissant}
\label{SANcroissant}
\end{figure}

On remarque que très rapidement, les courbes des solutions approchées se confondent avec la courbe de la solution analytique. On peut déjà prétendre que la solution approchée converge vers la solution exacte quand le nombre de nœuds augmente.

\subsubsection{Erreur relative}
\begin{figure}[H]
\begin{center}
	\includegraphics[width=0.7\textwidth]{{"FIG/Erreur relative fct de h"}.png}
\end{center}
\caption{Évolution de l'erreur relative en fonction de la finesse du maillage $h$}
\label{Erreur relative fct de h}
\end{figure}

\begin{figure}[H]
\begin{center}
	\includegraphics[width=0.7\textwidth]{{"FIG/Erreur relative fct de N"}.png}
\end{center}
\caption{Évolution de l'erreur relative en fonction du nombre de nœuds $h$}
\label{Erreur relative fct de N}
\end{figure}

Dans cette partie nous avons calculé et tracé l'erreur relative en fonction de l'évolution de $h$. L'erreur relative a été calculée au nœud $r_{n}=L$, à l'extrémité de la pale.
On remarque que l'erreur diminue si la finesse du maillage augmente. Cette diminution n'est pas linéaire. On peut en déduire qu'à partir d'un certain seuil, l'augmentation de la finesse ne sera plus intéressante d'un point de vue numérique. En effet, en augmentant le maillage, nous augmentons les efforts de calcul de la machine. À partir d'un certain seuil, le gain en précision devient négligeable, comme la courbe tend vers zéro.
Se pose alors la question de la capacité et la durée du calcul fait par la machine. Cette durée est aussi dépendante de la complexité du calcul, dans les cas en $2D$ et $3D$. 




\subsection{Influence du polynôme d'interpolation}

Malheureusement, par manque de temps, nous n'avons pas pu tester avec une interpolation polynomiale de degré 2. La solution approchée aurait était plus proche de la solution analytique, notamment par le fait que le nombre de nœuds augmente dans ce cadre.
Nous n'avons pas non-plus étudié l'erreur relative en tout point $x$. Cette erreur est plus importante entre deux nœud. En l'étudiant, nous aurions pu comparer l'influence du polynôme d'interpolation dans l'approximation de la solution.

\section{Conclusion}

Dans ce TP, nous avons pu programmer une méthode simple et rapide d'approximation d'équations différentielles linéaires d'ordre deux, grâce aux méthodes d'éléments finis et notamment la formulation faible. La solution approchée converge bien vers la solution analytique quand la finesse du maillage augmente.
Nous avons pu comparer les résultats avec la solution analytique qui était connue. 
Dans un cas où la solution n'est pas connue, nous n'avions plus de moyen analytique pour comparer les résultats. En expérimentant physiquement, les données pourront être comparées et un modèle peut en être déduit.
Dans les deux cas, le modèle en éléments finis doit tenir compte de la précision recherchée et surtout de la puissance de calcul nécessaire.
Les méthodes des éléments finis sont des outils de calculs très intéressants tant que l'on garde en tête les limites des modèles et des calculs numériques.

%\bibliographystyle{unsrtnat}
%\bibliography{MEF - TP 1}
	

\appendix 
\chapter{Code Python}
\section{Listes des fonctions}


\begin{python}
def section(L,N,k,S0,SL): #Foction S(r)
    a=(SL-S0)/L
    b=S0
    return ((a*(L/N)*(k-1)+b)+a*(L/N)*k+b)/2


def matrixA(E,L,N,S0,SL): #Algorithme de construction de la Matrice A
    A=np.zeros((N+1,N+1))
    h=L/N
    S1=section(L,N,1,S0,SL)
    SN=section(L,N,N,S0,SL)
    A[0,0]= (E*S1)/h
    A[0,1]= -(E*S1)/h
    A[1,0]= -(E*S1)/h
    A[1,1]= (E*S1)/h
    i=1
    while i<N:
        S=section(L,N,i,S0,SL)
        A[i,i]=A[i,i]+(E*S)/h
        A[i,i+1]=-(E*S)/h
        A[i+1,i]=-(E*S)/h
        A[i+1,i+1]=(E*S)/h
        i=i+1
    return A

def vecteurB(rho,omega,N,S0,SL): #Algorithme de construction du vecteur B
    B=np.zeros(N+1)
    h=L/N
    S1=section(L,N,1,S0,SL)
    SN=section(L,N,N,S0,SL)
    R=1*L/N #k-0=0 donc r1
    B[0]=rho*omega*omega*S1*h*(R/3)
    B[1]=rho*omega*omega*S1*h*(R/6)
    i=1
    while i<N:
        R1=i*L/N
        R2=(i+1)*L/N
        S=section(L,N,i,S0,SL)
        B[i]=B[i]+rho*omega*omega*S*h*(R1/3+R2/6)
        B[i+1]=rho*omega*omega*S*h*(R1/3+R2/6)
        i=i+1
    return B

def u2(E,L,rho,omega,N,S0,SL,r): #Solution analytique pour S variable.
    a=(SL-S0)/L
    b=S0
    y=((omega**2*rho)/(36*E*a**3))*(a*r*(-4*a**2*r**2-3*a*b*r+6*b**2)-6*(b-2*a*L)*((a*L+b)**2)*np.log(a*r+b)+6*np.log(b)*(b-2*a*L)*(a*L+b)**2)
    return y
\end{python}

\subsection{Paramètres du problème}

\begin{python}
#Paramettre du probleme:
S0=16.2
SL=6.7
L=51.5
err=0.076
rho=1600
E=21300*10**6
omega=2*np.pi
N=5 # Premiere etude avec N=5
\end{python}

\section{Étude pour N=5}
\subsection{Solution approchée pour N=5}
\begin{python}
A=matrixA(E,L,N,S0,SL)
B=vecteurB(rho,omega,N,S0,SL)
#Condition limite:
A[0,0]=1
A[0,1]=0
B[0]=0
uh=np.linalg.solve(A,B) #Resolution du syteme : solution approchee pour N=5

x=np.linspace(0,L,100) #Axe horizontale pour la solution analytique
r=np.linspace(0,L,N+1) #Array avec tout les noeuds en fonction de N
u5=u2(E,L,rho,omega,N,S0,SL,x)

p1=plt.plot(r,uh,marker='o',label='Solution Approchee Uh')
plt.plot(x,u2(E,L,rho,omega,N,S0,SL,x),'r',label='Solution Analytique U')
plt.legend(loc='lower right')
plt.xlabel('r',fontsize=12)
plt.ylabel('U & Uh',fontsize=12)
plt.title("Solutions Approchees & Analytique pour N="+str(N), fontsize=14)
plt.savefig('D:\Google Drive - Mohamed\Cours\S1\Element Fini\TP 1\U Uh N5.png',dpi=800)
\end{python}
\subsection{Erreur relative pour N=5}
\begin{python}
ur=u2(E,L,rho,omega,N,S0,SL,r) #On calcul les valeurs theoriques pour differents noeuds (array "r")
error=np.absolute(ur-uh)/ur #formule pour chaque point

plt.plot(r,error*100,marker='o') #pourcentage
#plt.axhline(y=err*100, hold=None)
plt.ylabel('$\epsilon$ : erreur relative en $\%$',fontsize=12)
plt.xlabel('$h$',fontsize=12)
plt.title("Erreur relative a differents noeuds pour N="+str(N), fontsize=14)
plt.savefig('D:\Google Drive - Mohamed\Cours\S1\Element Fini\TP 1\Erreur relative N5.png',dpi=800) 
\end{python}
\section{Étude pour différents N}
\subsection{Solutions Approchées pour différents N}
\begin{python}
#Paramettre du probleme:
S0=16.2
SL=6.7
L=51.5
err=0.076
rho=1600
E=21300*10**6
omega=2*np.pi
Nmin=4 #nombre de noeud minimal
Nmax=20 #nombre de noeud maximal

for i in range (Nmin,Nmax+1,4):
    N=i
    x=np.linspace(0,L,100)
    r=np.linspace(0,L,N+1)
    A=matrixA(E,L,N,S0,SL)
    B=vecteurB(rho,omega,N,S0,SL)
    #Condition limite:
    A[0,0]=1
    A[0,1]=0
    B[0]=0
    uh=np.linalg.solve(A,B)
    plt.plot(r,uh,label='N='+str(N),)
plt.plot(x,u2(E,L,rho,omega,N,S0,SL,x),'k',label='Solution Analytique')
plt.legend(loc='lower right')
plt.xlabel('$r$',fontsize=12)
plt.ylabel('$u_{i}$',fontsize=12)
plt.title("Solutions Approchees & Analytique", fontsize=14)
plt.savefig('D:\Google Drive - Mohamed\Cours\S1\Element Fini\TP 1\Solutions Approchees & Analytique.png',dpi=800)
\end{python}
\subsection{Erreur relative en fonction de h}

\begin{python}
error=np.zeros(Nmax)
H=np.zeros(Nmax)
for i in range (Nmin,Nmax):
    N=i
    h=L/N
    x=np.linspace(0,L,100)
    r=np.linspace(0,L,N+1)
    A=matrixA(E,L,N,S0,SL)
    B=vecteurB(rho,omega,N,S0,SL)
    #Condition limite:
    A[0,0]=1
    A[0,1]=0
    B[0]=0
    uh=np.linalg.solve(A,B)
    U=u2(E,L,rho,omega,N,S0,SL,r)
    error[i-Nmin]=(np.absolute(U[N]-uh[N])/U[N])
    H[i-Nmin]=h
plt.plot(H,error,label='$Err(h)$')
#plt.axhline(y=err, hold=None) #tracer ligne pour errmax
plt.ylabel('$\epsilon$ : erreur relative en $\%$ en fonction de N',fontsize=12)
plt.xlabel('h',fontsize=12)
plt.title("Erreur relative au noeud $r_{n}=L$", fontsize=14)
plt.savefig('D:\Google Drive - Mohamed\Cours\S1\Element Fini\TP 1\Erreur relative fct de h.png',dpi=800) 
\end{python}
\subsection{Erreur relative en fonction de N}

\begin{python}
plt.plot(L/H,error*100,label='$Err(N)$')
plt.ylabel('$\epsilon$ : erreur relative en $\%$ en fonction de N',fontsize=12)
plt.xlabel('N',fontsize=12)
plt.title("Erreur relative au noeud $r_{n}=L$", fontsize=14)
plt.savefig('D:\Google Drive - Mohamed\Cours\S1\Element Fini\TP 1\Erreur relative fct de N.png',dpi=800)
\end{python}

\section{Étude de l'erreur relative en fonction du polynôme interpolation}
\begin{python}
\end{python}


\end{document}
\grid
